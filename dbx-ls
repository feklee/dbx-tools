#!/bin/bash

source "`dirname $0`/init.sh"

OPTIONS[l]="detailed listing"
OPTIONS[R]="recursive listing"

NON_OPTION_ARGS="[PATH]"

DESCRIPTION=$(cat <<EOF
List information about the current Dropbox directory, or if
specified, about PATH.
EOF
	   )

dbx-parse-options "$@"
shift $((OPTIND-1))

DBX_PATH=`dbx-path "$1"`

function dbx-relative-path-from-match {
    P="${LINE##$1}"
    if test "$DBX_PATH" != /; then
	C=${#DBX_PATH}
	P="${P:$C}"
    fi
    P="${P:1}"
    test "$P" = / && P=""
    echo $P
}

function dbx-print-path-line {
    LINE="$1"
    MATCH="$2"
    TAIL="$3"
    test -v LONG && echo -n "$MATCH"
    echo `dbx-relative-path-from-match "$MATCH"`$TAIL
}

shopt -s nocasematch

dbx-test-option-enabled l && LONG=yes

dbxcli ls -l $S "$DBX_PATH" | \
    while read LINE; do
	if [[ $LINE =~ ^Revision ]]; then
	    # Heading
	    test -v LONG && echo "$LINE"
	elif [[ $LINE =~ ^-[[:blank:]]+-[[:blank:]]+-[[:blank:]]+ ]];
	then
	    # Directory
	    dbx-print-path-line "$LINE" "${BASH_REMATCH[0]}" /
	elif [[ $LINE =~ ^[^/]+ ]]; then
	    # Regular file
	    dbx-print-path-line "$LINE" "${BASH_REMATCH[0]}"
	fi
    done

exit

test -n "$ENABLED_OPTIONS" && S=-$ENABLED_OPTIONS || S=""
if dbx-test-option-enabled l; then
#TODO    if path is specified and -R; then
#TODO	if second line is for directory; then
#	    replace that with .
#	else
#	    
#	fi
    #    fi
    # Maybe go line by line, and check for matches:
    # dir -> skip, file -> only replace dirname
    test "$DBX_PATH" = / && HEAD=/ || HEAD="$DBX_PATH/"
    dbxcli ls $S "$DBX_PATH" | \
	sed "s|$DBX_PATH[^$ ]||i" | \
	sed "s|/||"
    exit
fi
